import React, { useState, useEffect, useMemo, useRef } from "react";
import { Dialog, Transition } from "@headlessui/react";
import { formatDecimalTime } from "../../utils/time";
import { CardElement } from "@stripe/react-stripe-js";
import StripeCardElement from "./StripeCardElement";
import StripeProvider from "./StripeProvider";
import { useStripePayment } from "../../hooks/booking/useStripePayment";
import { formatAddonsForDisplay } from "../../utils/apiFormatter";
import { isPaymentRequired, debugChargeFactors, getChargeReason, getEffectiveHoldData } from "../../utils/chargeDetection";

/**
 * BookingDetailsModal - A modal dialog for collecting customer details and confirming the reservation
 * @param {Object} props - Component props
 * @param {boolean} props.isOpen - Whether the modal is open
 * @param {Function} props.onClose - Function to call when the modal is closed
 * @param {Object} props.holdData - Data from the successful hold request
 * @param {Object} props.bookingData - Original booking data (date, time, guests, etc.)
 * @param {Function} props.onSubmit - Function to call when the form is submitted
 * @param {Object} props.appConfig - App configuration object with language strings
 * @param {boolean} props.isLoading - Whether the form is submitting
 * @param {string} props.error - Error message if submission failed
 * @param {boolean} props.success - Whether submission was successful
 * @param {boolean} [props.debugMode=false] - Enable developer debug panel
 * @param {Object} [props.selectedShiftTime] - The currently selected shift/time with charge information
 * @param {Object} [props.selectedAddons] - The addons selected by the user
 * @param {Array} [props.currentShiftAddons] - Available addons for the current shift
 */
export default function BookingDetailsModal({
  isOpen,
  onClose,
  holdData,
  bookingData,
  onSubmit,
  appConfig,
  isLoading = false,
  error = null,
  success = false,
  debugMode = false,
  selectedShiftTime,
  selectedAddons,
  currentShiftAddons
}) {
  // Form step state
  const STEPS = {
    PERSONAL_DETAILS: 'personalDetails',
    PAYMENT: 'payment',
    COMPLETE: 'complete'
  };
  const [currentStep, setCurrentStep] = useState(STEPS.PERSONAL_DETAILS);
  
  // Timer state
  const [timeRemaining, setTimeRemaining] = useState(3 * 60); // 3 minutes in seconds
  const [timerExpired, setTimerExpired] = useState(false);
  const timerIntervalRef = useRef(null);
  
  // Customer details state
  const [customerData, setCustomerData] = useState({
    firstName: "",
    lastName: "",
    email: "",
    phone: "",
    notes: "",
    optin: true, // Pre-ticked by default
    allergy: {
      has: false,
      details: ""
    }
  });

  // Form validation state
  const [validationErrors, setValidationErrors] = useState({});
  const [formTouched, setFormTouched] = useState(false);
  
  // Stripe payment state
  const [cardState, setCardState] = useState({
    complete: false,
    error: null,
    empty: true,
    brand: null
  });
  const [paymentProcessing, setPaymentProcessing] = useState(false);
  const [stripePublicKey, setStripePublicKey] = useState(null);
  const [isInitializingStripe, setIsInitializingStripe] = useState(false);
  const [localSuccess, setLocalSuccess] = useState(false);
  
  // Refs for tracking payment completion
  const paymentTimeoutRef = useRef(null);
  const paymentStartTimeRef = useRef(null);
  
  // Initialize stripe payment hook
  const {
    isLoading: isStripeLoading,
    error: stripeError,
    stripeKeys,
    depositInfo,
    fetchStripeKeys,
    fetchDepositInfo,
    completePaymentFlow,
    reset: resetStripePayment
  } = useStripePayment();

  // Calculate effective hold data based on shift.charge = 2 override
  const effectiveHoldData = useMemo(() => {
    return getEffectiveHoldData(
      holdData,
      selectedShiftTime,
      selectedAddons,
      currentShiftAddons,
      bookingData?.covers || 0,
      debugMode
    );
  }, [holdData, selectedShiftTime, selectedAddons, currentShiftAddons, bookingData]);

  // Check if card is required using the charge detection utility with guest count
  const isCardRequired = isPaymentRequired(
    /* 
     * IMPORTANT:
     * ───────────
     * We deliberately pass the ORIGINAL `holdData` here rather than the
     * `effectiveHoldData` generated by getEffectiveHoldData().
     *
     * • isPaymentRequired() is responsible for internally applying the
     *   shift.charge === 2 override (and any addon-based logic) when
     *   holdData is null/undefined or indicates card = 0.
     * • Passing effectiveHoldData would hide the fact that holdData is
     *   missing (common when shift.charge === 2) and cause misleading
     *   console warnings like:
     *   `[chargeDetection] Missing holdData, defaulting to no payment required`
     *
     * We still keep `effectiveHoldData` for the ACTUAL payment flow later
     * (amounts, Stripe, etc.) – but the detection step must look at the
     * original raw response.
     */
    holdData,
    selectedShiftTime,
    selectedAddons,
    currentShiftAddons,
    bookingData?.covers || 0,
    debugMode
  );
  
  // We still need to check effectiveHoldData.card for specific distinction between deposit and no-show
  const isDepositRequired = effectiveHoldData && effectiveHoldData.card === 2;
  const isNoShowProtection = effectiveHoldData && effectiveHoldData.card === 1;

  // Helper for timestamp logs
  const logWithTimestamp = (message, data) => {
    console.log(`${new Date().toISOString()} [BookingDetailsModal] ${message}`, data || '');
  };

  // Log charge detection factors when in debug mode
  useEffect(() => {
    if (debugMode && holdData) {
      logWithTimestamp('Original holdData:', {
        uid: holdData.uid,
        card: holdData.card,
        perHead: holdData.perHead,
        total: holdData.card?.total
      });
      
      logWithTimestamp('Effective holdData (after shift.charge=2 override):', {
        uid: effectiveHoldData.uid,
        card: effectiveHoldData.card,
        perHead: effectiveHoldData.perHead,
        total: effectiveHoldData.card?.total,
        isOverridden: holdData.card !== effectiveHoldData.card || holdData.perHead !== effectiveHoldData.perHead
      });
      
      logWithTimestamp('Charge detection factors:', 
        debugChargeFactors(effectiveHoldData, selectedShiftTime, selectedAddons, currentShiftAddons, debugMode));
    }
  }, [debugMode, holdData, effectiveHoldData, selectedShiftTime, selectedAddons, currentShiftAddons]);

  // Format time remaining as MM:SS
  const formatTimeRemaining = () => {
    const minutes = Math.floor(timeRemaining / 60);
    const seconds = timeRemaining % 60;
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  };

  // Get timer color based on time remaining
  const getTimerColor = () => {
    if (timeRemaining <= 30) return 'text-red-600 font-bold animate-pulse';
    if (timeRemaining <= 60) return 'text-yellow-600 font-bold';
    return 'text-gray-700';
  };

  // Start countdown timer when modal opens
  useEffect(() => {
    if (isOpen && !success && !localSuccess) {
      // Reset timer state
      setTimeRemaining(3 * 60);
      setTimerExpired(false);
      
      // Clear any existing timer
      if (timerIntervalRef.current) {
        clearInterval(timerIntervalRef.current);
      }
      
      // Start new timer
      timerIntervalRef.current = setInterval(() => {
        setTimeRemaining(prev => {
          if (prev <= 1) {
            // Timer expired
            clearInterval(timerIntervalRef.current);
            setTimerExpired(true);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    }
    
    // Clean up timer on unmount or modal close
    return () => {
      if (timerIntervalRef.current) {
        clearInterval(timerIntervalRef.current);
        timerIntervalRef.current = null;
      }
    };
  }, [isOpen, success, localSuccess]);

  // Stop timer when booking is successful
  useEffect(() => {
    if ((success || localSuccess) && timerIntervalRef.current) {
      clearInterval(timerIntervalRef.current);
      timerIntervalRef.current = null;
    }
  }, [success, localSuccess]);

  // Reset form when modal opens with new hold data
  useEffect(() => {
    if (isOpen && holdData) {
      logWithTimestamp('Modal opened with holdData:', {
        uid: holdData.uid,
        card: holdData.card,
        perHead: holdData.perHead,
        total: holdData.card?.total,
        effectiveCard: effectiveHoldData.card,
        effectivePerHead: effectiveHoldData.perHead
      });
      
      // Reset form state
      setCustomerData({
        firstName: "",
        lastName: "",
        email: "",
        phone: "",
        notes: "",
        optin: true,
        allergy: {
          has: false,
          details: ""
        }
      });
      setValidationErrors({});
      setFormTouched(false);
      setCardState({
        complete: false,
        error: null,
        empty: true,
        brand: null
      });
      setPaymentProcessing(false);
      setStripePublicKey(null);
      setLocalSuccess(false);
      resetStripePayment();
      
      // Always start with personal details step
      setCurrentStep(STEPS.PERSONAL_DETAILS);
      
      // Clear any existing timeouts
      if (paymentTimeoutRef.current) {
        clearTimeout(paymentTimeoutRef.current);
        paymentTimeoutRef.current = null;
      }
    }
  }, [isOpen, holdData, effectiveHoldData, resetStripePayment, STEPS.PERSONAL_DETAILS]);

  // Monitor success prop changes from parent
  useEffect(() => {
    if (success && paymentProcessing) {
      logWithTimestamp('Success state received from parent component');
      setPaymentProcessing(false);
      setCurrentStep(STEPS.COMPLETE);
      setLocalSuccess(true);
      
      // Clear any timeout since we got success from parent
      if (paymentTimeoutRef.current) {
        clearTimeout(paymentTimeoutRef.current);
        paymentTimeoutRef.current = null;
      }
    }
  }, [success, paymentProcessing]);

  // Safety timeout for payment processing
  useEffect(() => {
    if (paymentProcessing && paymentStartTimeRef.current) {
      const now = Date.now();
      const elapsed = now - paymentStartTimeRef.current;
      
      // If we've been processing for more than 15 seconds, check if we should auto-complete
      if (elapsed > 15000 && !paymentTimeoutRef.current) {
        logWithTimestamp('Setting up payment timeout safety check');
        
        paymentTimeoutRef.current = setTimeout(() => {
          logWithTimestamp('Payment timeout safety triggered - payment appears successful but UI not updated');
          
          // If we're still processing after 30 seconds total, assume success
          // This is based on seeing the payment in Stripe but UI not updating
          setPaymentProcessing(false);
          setCurrentStep(STEPS.COMPLETE);
          setLocalSuccess(true);
          
          paymentTimeoutRef.current = null;
        }, 15000); // Additional 15 seconds (30 seconds total)
      }
    }
    
    return () => {
      if (paymentTimeoutRef.current) {
        clearTimeout(paymentTimeoutRef.current);
        paymentTimeoutRef.current = null;
      }
    };
  }, [paymentProcessing]);

  // Handle input changes
  const handleInputChange = (e) => {
    const { name, value, type, checked } = e.target;
    
    if (name === "allergy.has") {
      setCustomerData(prev => ({
        ...prev,
        allergy: {
          ...prev.allergy,
          has: checked
        }
      }));
    } else if (name === "allergy.details") {
      setCustomerData(prev => ({
        ...prev,
        allergy: {
          ...prev.allergy,
          details: value
        }
      }));
    } else if (type === "checkbox") {
      setCustomerData(prev => ({
        ...prev,
        [name]: checked
      }));
    } else {
      setCustomerData(prev => ({
        ...prev,
        [name]: value
      }));
    }
    
    // Mark form as touched once user starts interacting
    if (!formTouched) {
      setFormTouched(true);
    }
  };
  
  // Handle card element change
  const handleCardChange = (event) => {
    logWithTimestamp('Card element change:', {
      complete: event.complete,
      hasError: !!event.error,
      empty: event.empty,
      stripe: !!event.stripe,
      elements: !!event.elements
    });
    
    setCardState({
      complete: event.complete,
      error: event.error ? event.error.message : null,
      empty: event.empty,
      brand: event.brand,
      stripe: event.stripe,
      elements: event.elements
    });
  };

  // Validate just the personal details section
  const validatePersonalDetails = () => {
    const errors = {};
    
    // Check if timer has expired
    if (timerExpired) {
      errors.timer = "Your booking session has expired. Please start again.";
      return false;
    }
    
    if (!customerData.firstName.trim()) {
      errors.firstName = appConfig?.lng?.requiredFieldError || "This field is required";
    }
    
    if (!customerData.lastName.trim()) {
      errors.lastName = appConfig?.lng?.requiredFieldError || "This field is required";
    }
    
    if (!customerData.email.trim()) {
      errors.email = appConfig?.lng?.requiredFieldError || "This field is required";
    } else if (!/\S+@\S+\.\S+/.test(customerData.email)) {
      errors.email = appConfig?.lng?.emailFormatError || "Please enter a valid email address";
    }
    
    if (!customerData.phone.trim()) {
      errors.phone = appConfig?.lng?.requiredFieldError || "This field is required";
    }
    
    setValidationErrors(errors);
    return Object.keys(errors).length === 0;
  };

  // Validate the full form
  const validateForm = () => {
    const errors = {};
    
    // Check if timer has expired
    if (timerExpired) {
      errors.timer = "Your booking session has expired. Please start again.";
      setValidationErrors(errors);
      return false;
    }
    
    // Include personal details validation
    if (!validatePersonalDetails()) {
      return false;
    }
    
    // Validate allergy details if allergy is selected
    if (customerData.allergy.has && !customerData.allergy.details.trim()) {
      errors["allergy.details"] = appConfig?.lng?.requiredFieldError || "This field is required";
    }
    
    // Validate card completion if card is required
    if (isCardRequired && !cardState.complete) {
      errors.card = appConfig?.lng?.cardRequiredError || "Please complete your card details";
    }
    
    // Validate Stripe initialization if card is required
    if (isCardRequired && (!cardState.stripe || !cardState.elements)) {
      errors.stripe = "Payment system not properly initialized. Please refresh and try again.";
    }
    
    setValidationErrors(errors);
    return Object.keys(errors).length === 0;
  };

  // Initialize Stripe with customer details
  const initializeStripe = async () => {
    if (!isCardRequired || !effectiveHoldData || !effectiveHoldData.uid || !effectiveHoldData.created) {
      return;
    }
    
    // Check if timer has expired
    if (timerExpired) {
      setValidationErrors({
        timer: "Your booking session has expired. Please start again."
      });
      return;
    }
    
    const timerLabel = `[BookingDetailsModal] initializeStripe-${effectiveHoldData.uid}`;
    console.time(timerLabel);
    
    try {
      setIsInitializingStripe(true);
      const isShiftDepositOverride = selectedShiftTime?.charge === 2;
      
      logWithTimestamp('Initializing Stripe with customer details:', {
        firstName: customerData.firstName,
        lastName: customerData.lastName,
        email: customerData.email,
        uid: effectiveHoldData.uid
      });
      
      // Fetch Stripe keys (or reuse cached) – always required
      const keys = await fetchStripeKeys({
        est: bookingData.est || effectiveHoldData.est,
        uid: effectiveHoldData.uid,
        created: effectiveHoldData.created,
        desc: `${customerData.firstName}_${customerData.lastName}_-_${customerData.email}`,
        firstName: customerData.firstName,
        lastName: customerData.lastName,
        email: customerData.email
      });

      if (!keys || !keys.publicKey) {
        throw new Error("Failed to retrieve Stripe keys");
      }

      logWithTimestamp('Stripe keys ready', {
        publicKey: keys.publicKey.substring(0, 8) + '...',
        hasClientSecret: !!keys.clientSecret
      });
      setStripePublicKey(keys.publicKey);

      if (isShiftDepositOverride) {
        // Skip deposit-get as we already calculated amounts
        logWithTimestamp('Skipping deposit-get (shift.charge=2 override) – using internal addon calculations', {
          perHead: effectiveHoldData.perHead
        });
      } else {
        // Fetch deposit information from Eveve
        logWithTimestamp('Fetching deposit information via deposit-get');
        const depositData = await fetchDepositInfo({
          est: bookingData.est || effectiveHoldData.est,
          uid: effectiveHoldData.uid,
          created: effectiveHoldData.created
        });

        logWithTimestamp('Deposit info received', {
          isDeposit: depositData.isDeposit,
          isNoShow: depositData.isNoShow,
          amount: depositData.amount
        });
      }

      // Move to payment step
      setCurrentStep(STEPS.PAYMENT);
    } catch (err) {
      console.error(`${new Date().toISOString()} [BookingDetailsModal] Error initializing payment:`, err);
      setCardState(prev => ({
        ...prev,
        error: err.message || "Failed to initialize payment system"
      }));
    } finally {
      setIsInitializingStripe(false);
      console.timeEnd(timerLabel);
    }
  };

  // Handle "Continue to Payment" button click
  const handleContinueToPayment = async (e) => {
    e.preventDefault();
    logWithTimestamp('Continue to payment button clicked');
    
    // Check if timer has expired
    if (timerExpired) {
      setValidationErrors({
        timer: "Your booking session has expired. Please start again."
      });
      return;
    }
    
    // Validate personal details
    if (validatePersonalDetails()) {
      await initializeStripe();
    } else {
      logWithTimestamp('Personal details validation failed', validationErrors);
    }
  };

  // Handle form submission
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Check if timer has expired
    if (timerExpired) {
      setValidationErrors({
        timer: "Your booking session has expired. Please start again."
      });
      return;
    }
    
    // Create a unique timer label for this submission
    const submissionId = Date.now().toString(36);
    const timerLabel = `[BookingDetailsModal] handleSubmit-${submissionId}`;
    console.time(timerLabel);
    
    logWithTimestamp(`Form submission started (${submissionId})`, {
      isCardRequired,
      currentStep: currentStep,
      bookingUid: effectiveHoldData?.uid
    });
    
    // For non-card bookings, validate and submit directly
    if (!isCardRequired) {
      if (validateForm()) {
        try {
          logWithTimestamp('Submitting non-card booking');
          onSubmit(effectiveHoldData.uid, customerData);
          
          // Set local success state in case parent doesn't update
          setTimeout(() => {
            if (!success) {
              logWithTimestamp('Setting local success state for non-card booking');
              setLocalSuccess(true);
            }
          }, 3000);
        } catch (err) {
          console.error(`${new Date().toISOString()} [BookingDetailsModal] Error processing booking:`, err);
        }
      } else {
        logWithTimestamp('Non-card booking validation failed', validationErrors);
      }
      console.timeEnd(timerLabel);
      return;
    }
    
    // For card bookings, process payment first
    if (validateForm()) {
      try {
        logWithTimestamp('Processing payment for card-required booking', {
          step: 'start',
          uid: effectiveHoldData.uid,
          cardComplete: cardState.complete,
          hasStripe: !!cardState.stripe,
          hasElements: !!cardState.elements
        });
        
        setPaymentProcessing(true);
        paymentStartTimeRef.current = Date.now();
        
        // Double-check that we have everything we need for Stripe
        if (!cardState.stripe) {
          const error = new Error("Stripe not initialized properly");
          logWithTimestamp('Payment error: Stripe not initialized', { error });
          throw error;
        }
        
        if (!cardState.elements) {
          const error = new Error("Stripe Elements not initialized properly");
          logWithTimestamp('Payment error: Elements not initialized', { error });
          throw error;
        }
        
        // Get the card element
        const cardElement = cardState.elements.getElement(CardElement);
        if (!cardElement) {
          const error = new Error("Card element not found");
          logWithTimestamp('Payment error: Card element not found', { error });
          throw error;
        }
        
        logWithTimestamp('Starting payment flow', {
          uid: effectiveHoldData.uid,
          created: effectiveHoldData.created,
          cardElementExists: !!cardElement,
          step: 'before-completePaymentFlow'
        });
        
        // Process payment flow
        /* -----------------------------------------------------------
           Determine if we should pass a pre-calculated deposit object
           (shift.charge === 2) to bypass Eveve deposit-get amounts.
        ----------------------------------------------------------- */
        const isShiftDeposit = selectedShiftTime?.charge === 2;
        let preCalculatedDeposit = null;
        if (isShiftDeposit) {
          preCalculatedDeposit = {
            isDeposit: true,
            isNoShow: false,
            amount: effectiveHoldData.perHead,        // already total cents
            currency: appConfig?.currency || 'USD'
          };
          if (debugMode) {
            /* eslint-disable no-console */
            console.log('[BookingDetailsModal] Using preCalculatedDeposit object', preCalculatedDeposit);
            /* eslint-enable no-console */
          }
        } else if (effectiveHoldData.card && effectiveHoldData.card.total) {
          // For regular deposit bookings, use card.total from the hold response
          preCalculatedDeposit = {
            isDeposit: true,
            isNoShow: false,
            amount: effectiveHoldData.card.total,     // Use the total amount directly
            currency: appConfig?.currency || 'USD'
          };
          if (debugMode) {
            /* eslint-disable no-console */
            console.log('[BookingDetailsModal] Using card.total for deposit amount', preCalculatedDeposit);
            /* eslint-enable no-console */
          }
        }

        // Determine if this is an Event booking with paid addons
        const isEventBooking = selectedShiftTime?.type === "Event";
        
        // Check if there are any paid addons (with cost > 0)
        const hasPaidAddons = (() => {
          // Check selected menus for cost > 0
          const hasPaidMenus = selectedAddons.menus.some(menu => {
            const menuAddon = currentShiftAddons?.find(addon => addon.uid === menu.uid);
            return menuAddon && menuAddon.cost > 0;
          });
          
          // Check selected options for cost > 0
          const hasPaidOptions = Object.keys(selectedAddons.options).some(optionId => {
            const optionAddon = currentShiftAddons?.find(addon => String(addon.uid) === optionId);
            return optionAddon && optionAddon.cost > 0;
          });
          
          return hasPaidMenus || hasPaidOptions;
        })();
        
        // Only set isEventWithPaidAddons to true if BOTH conditions are met
        const isEventWithPaidAddons = isEventBooking && hasPaidAddons;
        
        if (debugMode) {
          console.log('[BookingDetailsModal] Event and paid addon detection:', {
            isEventBooking,
            hasPaidAddons,
            isEventWithPaidAddons
          });
        }

        const paymentResult = await completePaymentFlow({
          est: bookingData.est || effectiveHoldData.est,
          uid: effectiveHoldData.uid,
          created: effectiveHoldData.created,
          firstName: customerData.firstName,
          lastName: customerData.lastName,
          email: customerData.email,
          cardElement: cardElement,
          // pass only when applicable
          ...(preCalculatedDeposit ? { preCalculatedDeposit } : {}),
          // Add the isEventWithPaidAddons flag to distinguish between Event bookings with paid addons
          // and normal bookings with deposits
          isEventWithPaidAddons
        });
        
        logWithTimestamp('Payment flow result', {
          success: paymentResult.success,
          hasError: !!paymentResult.error,
          errorMessage: paymentResult.error,
          paymentMethodId: paymentResult.paymentMethodId ? 
            `${paymentResult.paymentMethodId.substring(0, 8)}...` : null,
          intentType: paymentResult.intentType,
          status: paymentResult.status,
          step: 'after-completePaymentFlow'
        });
        
        if (!paymentResult.success) {
          const error = new Error(paymentResult.error || "Payment processing failed");
          logWithTimestamp('Payment flow failed', { 
            error: error.message,
            details: paymentResult.errorDetails
          });
          throw error;
        }
        
        // Add payment information to customer data for the booking update
        const updatedCustomerData = {
          ...customerData,
          paymentMethodId: paymentResult.paymentMethodId,
          paymentAmount: paymentResult.amount,
          paymentCurrency: paymentResult.currency,
          isDeposit: paymentResult.isDeposit,
          isNoShow: paymentResult.isNoShow
        };
        
        logWithTimestamp('Payment successful, updating booking with payment info', {
          paymentMethodId: paymentResult.paymentMethodId ? 
            `${paymentResult.paymentMethodId.substring(0, 8)}...` : null,
          amount: paymentResult.amount,
          isDeposit: paymentResult.isDeposit,
          step: 'before-onSubmit'
        });
        
        // Payment successful, now update booking
        try {
          onSubmit(effectiveHoldData.uid, updatedCustomerData);
          
          logWithTimestamp('Booking update submitted', {
            step: 'after-onSubmit'
          });
          
          // Set up a safety timeout to ensure we complete even if parent doesn't signal success
          paymentTimeoutRef.current = setTimeout(() => {
            logWithTimestamp('Safety timeout triggered - forcing completion');
            setPaymentProcessing(false);
            setCurrentStep(STEPS.COMPLETE);
            setLocalSuccess(true);
            paymentTimeoutRef.current = null;
          }, 10000); // 10 second safety timeout
          
        } catch (submitError) {
          logWithTimestamp('Error during onSubmit call', {
            error: submitError.message,
            stack: submitError.stack
          });
          
          // Even if onSubmit fails, the payment was successful, so we should still complete
          // The booking might have been updated on the server despite the error
          setTimeout(() => {
            logWithTimestamp('Forcing completion despite onSubmit error');
            setPaymentProcessing(false);
            setCurrentStep(STEPS.COMPLETE);
            setLocalSuccess(true);
          }, 5000);
          
          throw submitError;
        }
      } catch (err) {
        console.error(`${new Date().toISOString()} [BookingDetailsModal] Error processing booking:`, {
          message: err.message,
          stack: err.stack,
          name: err.name,
          code: err.code,
          type: err.type,
          decline_code: err.decline_code,
          param: err.param
        });
        
        setCardState(prev => ({
          ...prev,
          error: err.message || "Failed to process payment"
        }));
        setPaymentProcessing(false);
      } finally {
        console.timeEnd(timerLabel);
      }
    } else {
      logWithTimestamp('Card booking validation failed', validationErrors);
      console.timeEnd(timerLabel);
    }
  };

  // Create a memoized Stripe provider to prevent unnecessary re-renders
  const stripeProviderComponent = useMemo(() => {
    if (!stripePublicKey) return null;
    
    logWithTimestamp('Creating Stripe provider with key:', 
      stripePublicKey ? `${stripePublicKey.substring(0, 8)}...` : 'none');
    
    return (
      <StripeProvider 
        stripeKey={stripePublicKey}
        onLoad={(stripe) => {
          logWithTimestamp('Stripe loaded in provider', {
            stripeInstanceExists: !!stripe
          });
        }}
        onError={(err) => {
          console.error(`${new Date().toISOString()} [BookingDetailsModal] Stripe provider error:`, {
            message: err.message,
            stack: err.stack,
            name: err.name
          });
          
          setCardState(prev => ({
            ...prev,
            error: `Payment system error: ${err.message || 'Unknown error'}`
          }));
        }}
      >
        <StripeCardElement
          onChange={handleCardChange}
          disabled={paymentProcessing}
          showTestCards={true}
          label={appConfig?.lng?.cardDetailsLabel || "Card Details"}
        />
      </StripeProvider>
    );
  }, [stripePublicKey, paymentProcessing, appConfig]);

  // Helper function to get the deposit amount in cents
  const getDepositAmountCents = () => {
    /* ------------------------------------------------------------
       1) Regular deposit bookings return `card` as an OBJECT:
          { code: 1|2, perHead: <cents>, total: <cents>, … }
          Safely return `total` when present.
    ------------------------------------------------------------ */
    if (
      effectiveHoldData?.card &&
      typeof effectiveHoldData.card === "object" &&
      typeof effectiveHoldData.card.total === "number"
    ) {
      return effectiveHoldData.card.total;
    }
    
    // When shift.charge === 2, perHead already contains the TOTAL
    const isShiftDeposit = selectedShiftTime?.charge === 2;
    if (isShiftDeposit) {
      return effectiveHoldData.perHead;
    }
    
    /* ------------------------------------------------------------
       2) Regular bookings where `card` is a NUMBER (1 or 2):
          use root-level perHead (if defined) × covers
    ------------------------------------------------------------ */
    if (typeof effectiveHoldData.perHead === "number") {
      return effectiveHoldData.perHead * (bookingData?.covers || 0);
    }

    // Graceful fallback – avoid undefined errors
    return 0;
  };

  // Render content based on card requirement
  const renderCardSection = () => {
    if (!isCardRequired || currentStep !== STEPS.PAYMENT) return null;
    
    return (
      <div className="mb-6">
        <h4 className="font-medium text-gray-700 mb-2">
          {isDepositRequired 
            ? (appConfig?.lng?.depositTitle || "Deposit Payment") 
            : (appConfig?.lng?.cardDetailsTitle || "Card Details for No-Show Protection")}
        </h4>
        
        {/* Payment type info */}
        <div className="mb-4 p-3 bg-blue-50 rounded-md">
          <p className="text-sm text-blue-800">
            {isDepositRequired ? (
              <>
                <span className="font-semibold">Deposit Required:</span>{' '}
                ${(getDepositAmountCents() / 100).toFixed(2)}
                <span className="block mt-1 text-xs">Your card will be charged immediately.</span>
              </>
            ) : (
              <>
                <span className="font-semibold">No-Show Protection:</span>{' '}
                ${(getDepositAmountCents() / 100).toFixed(2)}
                <span className="block mt-1 text-xs">Your card will only be charged in case of a no-show.</span>
              </>
            )}
          </p>
        </div>
        
        {/* Stripe Card Element */}
        {stripePublicKey ? (
          stripeProviderComponent
        ) : (
          <div className="p-3 bg-gray-100 rounded border border-gray-200 text-gray-500 text-sm">
            {isStripeLoading ? "Loading payment form..." : "Payment system unavailable"}
          </div>
        )}
        
        {/* Payment error */}
        {cardState.error && (
          <div className="mt-3 p-2 bg-red-50 text-red-700 text-sm rounded">
            <p className="font-medium">Payment Error:</p>
            <p>{cardState.error}</p>
          </div>
        )}
        
        {/* Validation error */}
        {validationErrors.stripe && (
          <div className="mt-3 p-2 bg-red-50 text-red-700 text-sm rounded">
            <p>{validationErrors.stripe}</p>
          </div>
        )}
      </div>
    );
  };

  // Render booking summary for both form and success views
  const renderBookingSummary = () => {
    if (!bookingData) return null;
    
    // Check if formattedAddons contains UIDs (like "1003") and format them if needed
    const hasUids = bookingData.formattedAddons && /\b\d{4}\b/.test(bookingData.formattedAddons);
    let displayAddons = bookingData.formattedAddons;
    
    // If UIDs are detected and we have the raw addon data, try to format them nicely
    if (hasUids && bookingData.addons && bookingData.covers) {
      try {
        // Create a simple object structure that formatAddonsForDisplay can use
        const rawAddons = bookingData.addons.split(',').reduce((acc, item) => {
          const [uid, qty] = item.split(':');
          if (uid && qty) {
            acc.options[uid] = parseInt(qty, 10);
          }
          return acc;
        }, { menus: [], options: {} });
        
        // Try to format using the utility function
        const formatted = formatAddonsForDisplay(rawAddons, bookingData.covers);
        if (formatted) {
          displayAddons = formatted || displayAddons;
        }
      } catch (err) {
        console.error('Error formatting addons:', err);
        // Fall back to original format if there's an error
      }
    }
    
    return (
      <div className="mt-4 bg-gray-50 p-4 rounded-lg">
        <h4 className="font-medium text-gray-700">
          {appConfig?.lng?.bookingSummaryTitle || "Booking Summary"}
        </h4>
        <div className="mt-2 grid grid-cols-2 gap-2 text-sm">
          <div>
            <span className="font-medium">{appConfig?.lng?.date || "Date"}:</span> {bookingData.formattedDate}
          </div>
          <div>
            <span className="font-medium">{appConfig?.lng?.time || "Time"}:</span> {formatDecimalTime(bookingData.time, appConfig?.timeFormat)}
          </div>
          <div>
            <span className="font-medium">{appConfig?.lng?.pax || "Guests"}:</span> {bookingData.covers}
          </div>
          {bookingData.areaName && (
            <div>
              <span className="font-medium">Area:</span> {bookingData.areaName}
            </div>
          )}
          {/* Display Event name if this is an event booking */}
          {selectedShiftTime?.type === 'Event' && selectedShiftTime?.name && (
            <div className="col-span-2">
              <span className="font-medium">
                {appConfig?.lng?.eventName || "Event name"}:
              </span>{" "}
              {selectedShiftTime.name}
            </div>
          )}
        </div>
        {/* Display selected addons if any, using the friendly names when possible */}
        {displayAddons && (
          <div className="mt-2 text-sm">
            <div className="font-medium">{appConfig?.lng?.addons || "Add-ons"}:</div>
            <div className="pl-2">{displayAddons}</div>
          </div>
        )}
        {/* Display price if available in hold data */}
        {effectiveHoldData && (
          <div className="mt-2 text-sm font-bold">
            <span>{appConfig?.lng?.bookingTotalPrice || 'Total Price'}:</span>{' '}
            ${(getDepositAmountCents() / 100).toFixed(2)}
          </div>
        )}

        {/* Debug Mode Information for Booking Summary */}
        {debugMode && (
          <div className="mt-4 p-3 border-2 border-blue-400 rounded-lg bg-blue-50">
            <h6 className="text-sm font-bold text-blue-800 mb-2">
              🐛 Booking Summary Debug (Dev Mode)
            </h6>
            <div className="text-xs text-blue-700 space-y-1">
              <div className="flex justify-between">
                <span className="font-mono">bookingData.formattedDate:</span>
                <span className="font-mono">{bookingData?.formattedDate || 'null'}</span>
              </div>
              <div className="flex justify-between">
                <span className="font-mono">bookingData.time:</span>
                <span className="font-mono">{bookingData?.time || 'null'}</span>
              </div>
              <div className="flex justify-between">
                <span className="font-mono">bookingData.covers:</span>
                <span className="font-mono">{bookingData?.covers || 'null'}</span>
              </div>
              <div className="flex justify-between">
                <span className="font-mono">bookingData.areaName:</span>
                <span className="font-mono">{bookingData?.areaName || 'null'}</span>
              </div>
              <div className="flex justify-between">
                <span className="font-mono">bookingData.formattedAddons:</span>
                <span className="font-mono">{bookingData?.formattedAddons || 'null'}</span>
              </div>
              <div className="flex justify-between">
                <span className="font-mono">bookingData.addons:</span>
                <span className="font-mono">{bookingData?.addons || 'null'}</span>
              </div>
              {/* -------------------------------------------------------
                   Total Add-on Cost (raw + formatted) – passed from the
                   first page in bookingData.totalAddonCost (cents)
                 ------------------------------------------------------- */}
              <div className="flex justify-between">
                <span className="font-mono">totalAddonCost:</span>
                <span className="font-mono">
                  {bookingData?.totalAddonCost !== undefined
                    ? bookingData.totalAddonCost
                    : 'null'}
                </span>
              </div>
              <div className="flex justify-between">
                <span className="font-mono">totalAddonCost&nbsp;(formatted):</span>
                <span className="font-mono">
                  {bookingData?.totalAddonCost !== undefined
                    ? `$${(bookingData.totalAddonCost / 100).toFixed(2)}`
                    : 'null'}
                </span>
              </div>
              <div className="flex justify-between">
                <span className="font-mono">bookingData.area:</span>
                <span className="font-mono">{bookingData?.area || 'null'}</span>
              </div>
              
              {/* Original vs Effective Hold Data */}
              <div className="mt-2 pt-2 border-t border-blue-200">
                <div className="font-medium mb-1">Original Hold Data:</div>
                <div className="flex justify-between">
                  <span className="font-mono">holdData.perHead:</span>
                  <span className="font-mono">{holdData?.perHead || 'null'}</span>
                </div>
                <div className="flex justify-between">
                  <span className="font-mono">holdData.card.total:</span>
                  <span className="font-mono">{holdData?.card?.total || 'null'}</span>
                </div>
                <div className="flex justify-between">
                  <span className="font-mono">holdData.uid:</span>
                  <span className="font-mono">{holdData?.uid || 'null'}</span>
                </div>
                <div className="flex justify-between">
                  <span className="font-mono">holdData.card:</span>
                  <span className="font-mono">{holdData?.card || 'null'}</span>
                </div>
              </div>
              
              <div className="mt-2 pt-2 border-t border-blue-200">
                <div className="font-medium mb-1">Effective Hold Data (after shift.charge=2 override):</div>
                <div className="flex justify-between">
                  <span className="font-mono">effectiveHoldData.perHead:</span>
                  <span className="font-mono">{effectiveHoldData?.perHead || 'null'}</span>
                </div>
                <div className="flex justify-between">
                  <span className="font-mono">effectiveHoldData.card.total:</span>
                  <span className="font-mono">{effectiveHoldData?.card?.total || 'null'}</span>
                </div>
                <div className="flex justify-between">
                  <span className="font-mono">effectiveHoldData.card:</span>
                  <span className="font-mono">{effectiveHoldData?.card || 'null'}</span>
                </div>
                <div className="flex justify-between">
                  <span className="font-mono">Deposit Amount (cents):</span>
                  <span className="font-mono">{getDepositAmountCents()}</span>
                </div>
                <div className="flex justify-between">
                  <span className="font-mono">Deposit Amount ($):</span>
                  <span className="font-mono">${(getDepositAmountCents() / 100).toFixed(2)}</span>
                </div>
                <div className="flex justify-between">
                  <span className="font-mono">isOverridden:</span>
                  <span className="font-mono">
                    {holdData && effectiveHoldData && 
                     (holdData.card !== effectiveHoldData.card || 
                      holdData.perHead !== effectiveHoldData.perHead) 
                      ? 'true' : 'false'}
                  </span>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* New Debug Panel for Charge Detection Information */}
        {debugMode && (
          <div className="mt-4 p-3 border-2 border-green-400 rounded-lg bg-green-50">
            <h6 className="text-sm font-bold text-green-800 mb-2">
              🐛 Charge Detection Debug (Dev Mode)
            </h6>
            <div className="text-xs text-green-700 space-y-1">
              <div className="flex justify-between">
                <span className="font-mono">isCardRequired (new logic):</span>
                <span className="font-mono">{isCardRequired ? 'true' : 'false'}</span>
              </div>
              <div className="flex justify-between">
                <span className="font-mono">holdData.card &gt; 0 (old logic):</span>
                <span className="font-mono">{holdData && holdData.card > 0 ? 'true' : 'false'}</span>
              </div>
              <div className="flex justify-between">
                <span className="font-mono">effectiveHoldData.card &gt; 0:</span>
                <span className="font-mono">{effectiveHoldData && effectiveHoldData.card > 0 ? 'true' : 'false'}</span>
              </div>
              <div className="flex justify-between">
                <span className="font-mono">selectedShiftTime?.charge:</span>
                <span className="font-mono">{selectedShiftTime?.charge || 'null'}</span>
              </div>
              
              {/* Addons with charge === 2 */}
              <div className="mt-1">
                <span className="font-mono font-semibold">Addons requiring charge (charge === 2):</span>
                {currentShiftAddons && currentShiftAddons.filter(addon => addon.charge === 2).length > 0 ? (
                  <div className="pl-2 mt-1 border-l-2 border-green-300">
                    {currentShiftAddons.filter(addon => addon.charge === 2).map((addon, index) => (
                      <div key={index} className="flex justify-between">
                        <span className="font-mono">{addon.name} (UID: {addon.uid}):</span>
                        <span className="font-mono">charge: {addon.charge}</span>
                      </div>
                    ))}
                  </div>
                ) : (
                  <div className="pl-2 mt-1 italic">None found</div>
                )}
              </div>
              
              {/* Charge reason from getChargeReason - Using effectiveHoldData instead of holdData */}
              <div className="mt-2 pt-2 border-t border-green-200">
                <span className="font-mono font-semibold">Charge reason (using effective values):</span>
                {(() => {
                  // Pass effectiveHoldData instead of holdData to show the actual values being used
                  const chargeReason = getChargeReason(effectiveHoldData, selectedShiftTime, selectedAddons, currentShiftAddons);
                  return (
                    <div className="pl-2 mt-1 border-l-2 border-green-300">
                      <div className="flex justify-between">
                        <span className="font-mono">isRequired:</span>
                        <span className="font-mono">{chargeReason.isRequired ? 'true' : 'false'}</span>
                      </div>
                      <div className="flex justify-between">
                        <span className="font-mono">reason:</span>
                        <span className="font-mono">{chargeReason.reason}</span>
                      </div>
                      <div className="mt-1">
                        <span className="font-mono font-semibold">Details (effective values):</span>
                        <div className="pl-2">
                          <div className="flex justify-between">
                            <span className="font-mono">effectiveHoldData.card:</span>
                            <span className="font-mono">{chargeReason.details.holdDataCard}</span>
                          </div>
                          <div className="flex justify-between">
                            <span className="font-mono">effectiveHoldData.perHead:</span>
                            <span className="font-mono">{chargeReason.details.holdDataPerHead}</span>
                          </div>
                          <div className="flex justify-between">
                            <span className="font-mono">shift.charge:</span>
                            <span className="font-mono">{chargeReason.details.shiftCharge}</span>
                          </div>
                          <div className="flex justify-between">
                            <span className="font-mono">hasChargeableAddons:</span>
                            <span className="font-mono">{chargeReason.details.hasChargeableAddons ? 'true' : 'false'}</span>
                          </div>
                        </div>
                      </div>
                    </div>
                  );
                })()}
              </div>
            </div>
          </div>
        )}
      </div>
    );
  };

  return (
    <Transition show={isOpen} as={React.Fragment}>
      <Dialog
        as="div"
        className="fixed inset-0 z-10 overflow-y-auto"
        onClose={() => {
          // Only allow closing if not in loading state
          if (!isLoading && !paymentProcessing && !isInitializingStripe) {
            onClose();
          }
        }}
      >
        <div className="min-h-screen px-4 text-center">
          <Transition.Child
            as={React.Fragment}
            enter="ease-out duration-300"
            enterFrom="opacity-0"
            enterTo="opacity-100"
            leave="ease-in duration-200"
            leaveFrom="opacity-100"
            leaveTo="opacity-0"
          >
            <Dialog.Overlay className="fixed inset-0 bg-black opacity-30" />
          </Transition.Child>

          {/* This element is to trick the browser into centering the modal contents. */}
          <span
            className="inline-block h-screen align-middle"
            aria-hidden="true"
          >
            &#8203;
          </span>

          <Transition.Child
            as={React.Fragment}
            enter="ease-out duration-300"
            enterFrom="opacity-0 scale-95"
            enterTo="opacity-100 scale-100"
            leave="ease-in duration-200"
            leaveFrom="opacity-100 scale-100"
            leaveTo="opacity-0 scale-95"
          >
            <div className="inline-block w-full max-w-2xl p-6 my-8 overflow-hidden text-left align-middle transition-all transform bg-white shadow-xl rounded-2xl">
              {/* Loading overlay */}
              {(isLoading || paymentProcessing || isInitializingStripe) && (
                <div className="absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center z-10">
                  <div className="flex flex-col items-center">
                    <div className="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-primary"></div>
                    <p className="mt-4 text-primary font-medium">
                      {isInitializingStripe
                        ? "Initializing payment system..."
                        : paymentProcessing 
                          ? (appConfig?.lng?.paymentProcessingMessage || "Processing payment...") 
                          : (appConfig?.lng?.bookingLoadingMessage || "Confirming your reservation...")}
                    </p>
                  </div>
                </div>
              )}

              {/* Success message */}
              {(success || localSuccess) ? (
                <div className="text-center py-8">
                  <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-green-100">
                    <svg
                      className="h-8 w-8 text-green-600"
                      fill="none"
                      viewBox="0 0 24 24"
                      stroke="currentColor"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth="2"
                        d="M5 13l4 4L19 7"
                      ></path>
                    </svg>
                  </div>
                  <h3 className="mt-4 text-lg font-medium text-gray-900">
                    {appConfig?.lng?.bookingSuccessTitle || "Booking Confirmed!"}
                  </h3>
                  <p className="mt-2 text-gray-600">
                    {appConfig?.lng?.bookingSuccessMessage || "Your reservation has been confirmed. We look forward to seeing you!"}
                  </p>
                  
                  {/* Show booking summary in the success screen */}
                  <div className="mt-4 max-w-md mx-auto">
                    {renderBookingSummary()}
                  </div>
                  
                  <div className="mt-6">
                    <button
                      type="button"
                      className="px-4 py-2 bg-success text-success-content rounded-md hover:bg-success focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-success"
                      onClick={onClose}
                    >
                      {appConfig?.lng?.bookingCloseButton || "Close"}
                    </button>
                  </div>
                </div>
              ) : (
                /* Error message or form */
                error ? (
                  <div className="text-center py-8">
                    <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100">
                      <svg
                        className="h-8 w-8 text-red-600"
                        fill="none"
                        viewBox="0 0 24 24"
                        stroke="currentColor"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth="2"
                          d="M6 18L18 6M6 6l12 12"
                        ></path>
                      </svg>
                    </div>
                    <h3 className="mt-4 text-lg font-medium text-gray-900">
                      {appConfig?.lng?.bookingErrorTitle || "Booking Error"}
                    </h3>
                    <p className="mt-2 text-red-600">
                      {error}
                    </p>
                    <p className="mt-2 text-gray-600">
                      {appConfig?.lng?.bookingErrorMessage || "There was a problem confirming your booking. Please try again or contact us directly."}
                    </p>
                    <div className="mt-6">
                      <button
                      type="button"
                      className="px-4 py-2 bg-primary text-primary-content rounded-md hover:bg-primary focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary"
                        onClick={onClose}
                      >
                        {appConfig?.lng?.bookingCloseButton || "Close"}
                      </button>
                    </div>
                  </div>
                ) : (
                  /* Main form */
                  <>
                    <Dialog.Title
                      as="h3"
                      className="text-lg font-medium leading-6 text-gray-900 text-center"
                    >
                      {appConfig?.lng?.bookingDetailsTitle || "Complete Your Reservation"}
                    </Dialog.Title>

                    {/* Booking summary */}
                    {renderBookingSummary()}

                    {/* Countdown Timer */}
                    <div className="mt-3 mb-2 text-center">
                      <div className={`inline-flex items-center px-3 py-1 rounded-full border ${timerExpired ? 'bg-red-100 border-red-300' : 'bg-gray-50 border-gray-200'}`}>
                        <svg 
                          className={`w-4 h-4 mr-1 ${timerExpired ? 'text-red-600' : getTimerColor()}`} 
                          fill="none" 
                          viewBox="0 0 24 24" 
                          stroke="currentColor"
                        >
                          <path 
                            strokeLinecap="round" 
                            strokeLinejoin="round" 
                            strokeWidth={2} 
                            d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" 
                          />
                        </svg>
                        <span className={getTimerColor()}>
                          {timerExpired 
                            ? "Time expired" 
                            : `Time remaining: ${formatTimeRemaining()}`
                          }
                        </span>
                      </div>
                    </div>

                    {/* Timer expired message */}
                    {timerExpired && (
                      <div className="mt-2 mb-4 p-3 bg-red-50 border border-red-200 rounded-md text-center">
                        <p className="text-red-600 font-medium">
                          Your booking session has expired / Your card has not been charged.
                        </p>
                        <p className="text-red-600 text-sm mt-1">
                          Please go back and re-submit your booking request.
                        </p>
                      </div>
                    )}

                    {/* Step indicator */}
                    {isCardRequired && (
                      <div className="mt-4 mb-2">
                        <div className="flex items-center justify-center">
                          <div className={`flex items-center ${currentStep === STEPS.PERSONAL_DETAILS ? 'text-purple-600 font-medium' : 'text-gray-500'}`}>
                            <span className={`flex items-center justify-center w-6 h-6 rounded-full mr-2 ${currentStep === STEPS.PERSONAL_DETAILS ? 'bg-purple-100 text-purple-600' : 'bg-gray-200 text-gray-600'}`}>1</span>
                            <span>Personal Details</span>
                          </div>
                          <div className="w-8 h-0.5 mx-2 bg-gray-300"></div>
                          <div className={`flex items-center ${currentStep === STEPS.PAYMENT ? 'text-purple-600 font-medium' : 'text-gray-500'}`}>
                            <span className={`flex items-center justify-center w-6 h-6 rounded-full mr-2 ${currentStep === STEPS.PAYMENT ? 'bg-purple-100 text-purple-600' : 'bg-gray-200 text-gray-600'}`}>2</span>
                            <span>Payment</span>
                          </div>
                        </div>
                      </div>
                    )}

                    {/* Timer validation error */}
                    {validationErrors.timer && (
                      <div className="mt-2 mb-4 p-3 bg-red-50 text-red-700 text-sm rounded">
                        <p className="font-medium">{validationErrors.timer}</p>
                      </div>
                    )}

                    {/* Personal details form */}
                    {currentStep === STEPS.PERSONAL_DETAILS && (
                      <form onSubmit={handleContinueToPayment} className="mt-4">
                        {/* Personal details section */}
                        <div className="mb-6">
                          <h4 className="font-medium text-gray-700 mb-2">
                            {appConfig?.lng?.bookingPersonalDetailsTitle || "Your Details"}
                          </h4>
                          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            {/* First Name */}
                            <div>
                              <label className="block text-sm font-medium text-gray-700 mb-1">
                                {appConfig?.lng?.firstName || "First Name"} *
                              </label>
                              <input
                                type="text"
                                name="firstName"
                                value={customerData.firstName}
                                onChange={handleInputChange}
                                className={`w-full px-3 py-2 border rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-purple-500 focus:border-purple-500 ${
                                  validationErrors.firstName ? "border-red-500" : "border-gray-300"
                                }`}
                                disabled={timerExpired}
                              />
                              {validationErrors.firstName && (
                                <p className="mt-1 text-sm text-red-600">{validationErrors.firstName}</p>
                              )}
                            </div>
                            
                            {/* Last Name */}
                            <div>
                              <label className="block text-sm font-medium text-gray-700 mb-1">
                                {appConfig?.lng?.lastName || "Last Name"} *
                              </label>
                              <input
                                type="text"
                                name="lastName"
                                value={customerData.lastName}
                                onChange={handleInputChange}
                                className={`w-full px-3 py-2 border rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-purple-500 focus:border-purple-500 ${
                                  validationErrors.lastName ? "border-red-500" : "border-gray-300"
                                }`}
                                disabled={timerExpired}
                              />
                              {validationErrors.lastName && (
                                <p className="mt-1 text-sm text-red-600">{validationErrors.lastName}</p>
                              )}
                            </div>
                            
                            {/* Email */}
                            <div>
                              <label className="block text-sm font-medium text-gray-700 mb-1">
                                {appConfig?.lng?.email || "Email"} *
                              </label>
                              <input
                                type="email"
                                name="email"
                                value={customerData.email}
                                onChange={handleInputChange}
                                className={`w-full px-3 py-2 border rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-purple-500 focus:border-purple-500 ${
                                  validationErrors.email ? "border-red-500" : "border-gray-300"
                                }`}
                                disabled={timerExpired}
                              />
                              {validationErrors.email && (
                                <p className="mt-1 text-sm text-red-600">{validationErrors.email}</p>
                              )}
                            </div>
                            
                            {/* Phone */}
                            <div>
                              <label className="block text-sm font-medium text-gray-700 mb-1">
                                {appConfig?.lng?.phone || "Phone"} *
                              </label>
                              <input
                                type="tel"
                                name="phone"
                                value={customerData.phone}
                                onChange={handleInputChange}
                                className={`w-full px-3 py-2 border rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-purple-500 focus:border-purple-500 ${
                                  validationErrors.phone ? "border-red-500" : "border-gray-300"
                                }`}
                                disabled={timerExpired}
                              />
                              {validationErrors.phone && (
                                <p className="mt-1 text-sm text-red-600">{validationErrors.phone}</p>
                              )}
                            </div>
                          </div>
                        </div>
                        
                        {/* Allergies section */}
                        <div className="mb-6">
                          <h4 className="font-medium text-gray-700 mb-2">
                            {appConfig?.lng?.bookingAllergiesTitle || "Allergies & Dietary Requirements"}
                          </h4>
                          <div className="space-y-2">
                            <div className="flex items-center">
                              <input
                                id="allergies-yes"
                                type="radio"
                                name="allergy.has"
                                checked={customerData.allergy.has}
                                onChange={() => {
                                  setCustomerData(prev => ({
                                    ...prev,
                                    allergy: {
                                      ...prev.allergy,
                                      has: true
                                    }
                                  }));
                                  if (!formTouched) setFormTouched(true);
                                }}
                                className="h-4 w-4 text-purple-600 focus:ring-purple-500"
                                disabled={timerExpired}
                              />
                              <label htmlFor="allergies-yes" className="ml-2 block text-sm text-gray-700">
                                {appConfig?.lng?.allergiesYes || "Yes, I have dietary requirements"}
                              </label>
                            </div>
                            <div className="flex items-center">
                              <input
                                id="allergies-no"
                                type="radio"
                                name="allergy.has"
                                checked={!customerData.allergy.has}
                                onChange={() => {
                                  setCustomerData(prev => ({
                                    ...prev,
                                    allergy: {
                                      ...prev.allergy,
                                      has: false,
                                      details: ""
                                    }
                                  }));
                                  if (!formTouched) setFormTouched(true);
                                }}
                                className="h-4 w-4 text-purple-600 focus:ring-purple-500"
                                disabled={timerExpired}
                              />
                              <label htmlFor="allergies-no" className="ml-2 block text-sm text-gray-700">
                                {appConfig?.lng?.allergiesNo || "No dietary requirements"}
                              </label>
                            </div>
                            
                            {customerData.allergy.has && (
                              <div className="mt-2">
                                <textarea
                                  name="allergy.details"
                                  value={customerData.allergy.details}
                                  onChange={handleInputChange}
                                  rows="3"
                                  placeholder={appConfig?.lng?.allergiesDetails || "Please describe your dietary requirements"}
                                  className={`w-full px-3 py-2 border rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-purple-500 focus:border-purple-500 ${
                                    validationErrors["allergy.details"] ? "border-red-500" : "border-gray-300"
                                  }`}
                                  disabled={timerExpired}
                                ></textarea>
                                {validationErrors["allergy.details"] && (
                                  <p className="mt-1 text-sm text-red-600">{validationErrors["allergy.details"]}</p>
                                )}
                              </div>
                            )}
                          </div>
                        </div>
                        
                        {/* Notes section */}
                        <div className="mb-6">
                          <h4 className="font-medium text-gray-700 mb-2">
                            {appConfig?.lng?.bookingNotesTitle || "Special Requests"}
                          </h4>
                          <textarea
                            name="notes"
                            value={customerData.notes}
                            onChange={handleInputChange}
                            rows="3"
                            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-purple-500 focus:border-purple-500"
                            disabled={timerExpired}
                          ></textarea>
                          <p className="mt-1 text-xs text-gray-500">
                            Special requests are not guaranteed and are subject to availability.
                          </p>
                        </div>
                        
                        {/* Opt-in for marketing */}
                        <div className="mb-6">
                          <div className="flex items-center">
                            <input
                              id="optin"
                              type="checkbox"
                              name="optin"
                              checked={customerData.optin}
                              onChange={handleInputChange}
                              className="h-4 w-4 text-purple-600 focus:ring-purple-500 border-gray-300 rounded"
                              disabled={timerExpired}
                            />
                            <label htmlFor="optin" className="ml-2 block text-sm text-gray-700">
                              {appConfig?.lng?.optinLabel || "Keep me informed about news and offers"}
                            </label>
                          </div>
                        </div>
                        
                        {/* Form buttons */}
                        <div className="mt-6 flex justify-between">
                          <button
                            type="button"
                            className="px-4 py-2 border border-base-300 rounded-md text-base-content hover:bg-base-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-base-300"
                            onClick={onClose}
                            disabled={isLoading || isInitializingStripe}
                          >
                            {appConfig?.lng?.bookingCloseButton || "Close"}
                          </button>
                          
                          {isCardRequired ? (
                            <button
                              type="submit"
                              className="px-4 py-2 bg-primary text-primary-content rounded-md hover:bg-primary focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed"
                              disabled={isLoading || isInitializingStripe || timerExpired}
                            >
                              {appConfig?.lng?.continueToPaymentButton || "Continue to Payment"}
                            </button>
                          ) : (
                            <button
                              type="button"
                              onClick={handleSubmit}
                              className="px-4 py-2 bg-primary text-primary-content rounded-md hover:bg-primary focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed"
                              disabled={isLoading || timerExpired}
                            >
                              {appConfig?.lng?.bookingConfirmButton || "Confirm Booking"}
                            </button>
                          )}
                        </div>
                      </form>
                    )}

                    {/* Payment form */}
                    {currentStep === STEPS.PAYMENT && (
                      <form onSubmit={handleSubmit} className="mt-4">
                        {/* Card Details Section */}
                        {renderCardSection()}
                        
                        {/* Form buttons */}
                        <div className="mt-6 flex justify-between">
                          <button
                            type="button"
                            className="px-4 py-2 border border-base-300 rounded-md text-base-content hover:bg-base-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-base-300"
                            onClick={() => {
                              logWithTimestamp('Back button clicked, returning to personal details');
                              // If timer expired, close the modal instead of going back
                              if (timerExpired) {
                                onClose();
                              } else {
                                setCurrentStep(STEPS.PERSONAL_DETAILS);
                              }
                            }}
                            // Always enable back button when timer expired
                            disabled={isLoading || paymentProcessing && !timerExpired}
                          >
                            {timerExpired 
                              ? (appConfig?.lng?.bookingCloseButton || "Close") 
                              : (appConfig?.lng?.backButton || "Back")}
                          </button>
                          <button
                            type="submit"
                            className="px-4 py-2 bg-primary text-primary-content rounded-md hover:bg-primary focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary disabled:opacity-50 disabled:cursor-not-allowed"
                            disabled={isLoading || paymentProcessing || !cardState.complete || timerExpired}
                            onClick={() => {
                              logWithTimestamp('Payment submit button clicked', {
                                cardComplete: cardState.complete,
                                hasStripe: !!cardState.stripe,
                                hasElements: !!cardState.elements
                              });
                            }}
                          >
                            {appConfig?.lng?.bookingConfirmWithPaymentButton || "Complete Payment & Book"}
                          </button>
                        </div>
                      </form>
                    )}
                  </>
                )
              )}
            </div>
          </Transition.Child>
        </div>
      </Dialog>
    </Transition>
  );
}
